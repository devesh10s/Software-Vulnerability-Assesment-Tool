#include <iostream>
#include <pqxx/pqxx>
#include <sqlite3.h>
#include "../3rdparty/json.hpp"
#include "cpe_to_cve.h"

#include <thread>
#include <utility>
#include "../common/hostinfo.h"
#include "../common/logger.h"
#include "../common/ConfigurationParser.h"

#include <boost/beast/http.hpp>
#include <boost/asio/ip/tcp.hpp>

#include <boost/algorithm/string.hpp>

Cve::Cve(std::shared_ptr<ConnectionPool> pool)
{
    this->pool = std::move(pool);
}

// Method to compare two versions.

// Returns 1 if v2 is smaller, -1
// if v1 is smaller, 0 if equa
int versionCompare(std::string v1, std::string v2)
{
    // vnum stores each numeric
    // part of version
    int vnum1 = 0, vnum2 = 0;

    // loop until both string are
    // processed
    for (int i = 0, j = 0; (i < v1.length() && j < v2.length());)
    {
        // storing numeric part of
        // version 1 in vnum1
        while (i < v1.length() && v1[i] != '.')
        {
            vnum1 = vnum1 * 10 + (v1[i] - '0');
            i++;
        }

        // storing numeric part of
        // version 2 in vnum2
        while (j < v2.length() && v2[j] != '.')
        {
            vnum2 = vnum2 * 10 + (v2[j] - '0');
            j++;
        }

        if (vnum1 > vnum2)
            return 1;
        if (vnum2 > vnum1)
            return -1;

        // if equal, reset variables and
        // go for next numeric part
        vnum1 = vnum2 = 0;
        i++;
        j++;
    }
    return 0;
}

[[noreturn]] void Cve::run_programs_cve()
{
    while (true)
    {
        std::unordered_map<std::string, std::string> prepared_queries;
        ConfigurationParser config_parser("config.json");
        if (!config_parser.parse())
        {
            BOOST_LOG_TRIVIAL(fatal) << __SRCREF__ << "Cannot read configuration";
        }
        VaServerConfiguration va = config_parser.GetVaServerConfiguration();

        std::shared_ptr<ConnectionPool> conn_pool(
            new ConnectionPool(va.database.ConnectionVaString(), va.database_pool.maximum_connections, prepared_queries));
        // Query PostgreSQL for rows in 'programs' table
        auto connection = pool->GetConnection();
        auto connection_va = conn_pool->GetConnection();
        connection->prepare("get_programs_cpe", "SELECT id, cpe_string, version FROM programs where is_cve_processed is not true and is_processed is true order by id asc limit 500");
        pqxx::work transaction{*connection};
        pqxx::result result_cpe = transaction.exec_prepared("get_programs_cpe");
        transaction.commit();
        connection->unprepare("get_programs_cpe");
        pqxx::result get_cve_records;

        if (!result_cpe.empty())
        {
            nlohmann::json cve_match_array, cve_record;
            cve_match_array = nlohmann::json::array();
            for (pqxx::result::const_iterator i = result_cpe.begin(); i != result_cpe.end(); ++i)
            {
                long long id = i["id"].as<long long>();
                std::string version = i["version"].as<std::string>();
                if (!i["cpe_string"].is_null())
                {
                    std::string cpe_string = i["cpe_string"].as<std::string>();
                    // cpe_string is stored as an array in the database, parse it into individual strings
                    std::vector<std::string> cpe_strings;
                    boost::split(cpe_strings, cpe_string, boost::is_any_of(","));

                    // Determine the limit for iterating through CPE strings (limit to the first 3 strings)
                    size_t cpe_limit = std::min(static_cast<size_t>(3), cpe_strings.size());

                    for (size_t idx = 0; idx < cpe_limit; ++idx)
                    {
                        const std::string &single_cpe_string = cpe_strings[idx];
                        std::string query1 = "select * from nvd_cves where cpe_string like '%" + single_cpe_string + "%'";
                        connection_va->prepare("get_cve_for_cpe", query1);
                        pqxx::work transaction{*connection_va};
                        get_cve_records = transaction.exec_prepared("get_cve_for_cpe");
                        transaction.commit();
                        connection_va->unprepare("get_cve_for_cpe");
                        if (get_cve_records.empty())
                        {
                            // Extracting the substring till 'cpe:2.3:{part}:{vendor}:{product}:'
                            //  Counting the delimiter occurrence to get the substring till the 5th delimiter
                            std::string delimiter = ":";
                            size_t delimiter_count = 0;
                            size_t pos = 0;
                            while (delimiter_count < 5 && (pos = single_cpe_string.find(delimiter, pos)) != std::string::npos)
                            {
                                ++delimiter_count;
                                pos += delimiter.length();
                            }

                            std::string modified_cpe_string;
                            if (delimiter_count >= 5)
                            {
                                modified_cpe_string = single_cpe_string.substr(0, pos - delimiter.length());
                            }
                            else
                            {
                                modified_cpe_string = single_cpe_string; // Use the entire string if less than 5 delimiters
                            }

                            std::string query1 = "select * from nvd_cves where cpe_string like '%" + modified_cpe_string + "%'";

                            connection_va->prepare("get_cve_for_cpe", query1);
                            get_cve_records = transaction.exec_prepared("get_cve_for_cpe");
                            transaction.commit();
                            connection_va->unprepare("get_cve_for_cpe");
                        }
                        std::cout << get_cve_records.size() << std::endl;
                        if (!get_cve_records.empty())
                        {
                            for (unsigned int i = 0; i < get_cve_records.size(); ++i)
                            {
                                try
                                {
                                    std::string record_id = get_cve_records.at(i)["id"].as<std::string>();
                                    std::string cve_id = get_cve_records.at(i)["cve_id"].as<std::string>();
                                    std::string published = get_cve_records.at(i)["published"].as<std::string>();
                                    std::string lastModified = get_cve_records.at(i)["lastModified"].as<std::string>();
                                    std::string vulnStatus = get_cve_records.at(i)["vulnStatus"].as<std::string>();
                                    std::string descriptions = get_cve_records.at(i)["descriptions"].as<std::string>();
                                    std::string metrics = get_cve_records.at(i)["metrics"].as<std::string>();
                                    std::string weaknesses = get_cve_records.at(i)["weaknesses"].as<std::string>();
                                    std::string configurations = get_cve_records.at(i)["configurations"].as<std::string>();
                                    std::string reference = get_cve_records.at(i)["reference"].as<std::string>();
                                    std::string cpe_string = get_cve_records.at(i)["cpe_string"].as<std::string>();
                                    // std::cout << cpe_string << std::endl;

                                    long baseScore = get_cve_records.at(i)["baseScore"].as<long>();
                                    std::string baseSeverity = get_cve_records.at(i)["baseSeverity"].as<std::string>();
                                    long long exploitabilityScore = get_cve_records.at(i)["exploitabilityScore"].as<long long>();
                                    long long impactScore = get_cve_records.at(i)["impactScore"].as<long long>();
                                    std::string versionStartIncluding = get_cve_records.at(i)["versionStartIncluding"].as<std::string>();
                                    // std::cout << versionStartIncluding << std::endl;
                                    std::string versionEndIncluding = get_cve_records.at(i)["versionEndIncluding"].as<std::string>();
                                    // std::cout << versionEndIncluding << std::endl;

                                    if (versionCompare(versionStartIncluding, version) <= 0)
                                    {
                                        if (versionCompare(versionEndIncluding, version) >= 0)
                                        {
                                            // std::cout << version << " vulnerable\n";

                                            cve_record["id"] = record_id;
                                            cve_record["cve_id"] = cve_id;
                                            cve_record["published"] = published;
                                            cve_record["lastModified"] = lastModified;
                                            cve_record["vulnStatus"] = vulnStatus;
                                            cve_record["descriptions"] = descriptions;
                                            cve_record["metrics"] = metrics;
                                            cve_record["weaknesses"] = weaknesses;
                                            cve_record["configurations"] = configurations;
                                            cve_record["reference"] = reference;
                                            cve_record["cpe_string"] = cpe_string;
                                            cve_record["baseScore"] = baseScore;
                                            cve_record["baseSeverity"] = baseSeverity;
                                            cve_record["exploitabilityScore"] = exploitabilityScore;
                                            cve_record["impactScore"] = impactScore;

                                            cve_match_array.push_back(cve_record);
                                            // std::cout << cve_match_array << std::endl;
                                        }
                                    }
                                }
                                catch (const std::exception &e)
                                {
                                    std::cerr << e.what() << std::endl;
                                }
                            }
                        }
                    }
                    // Convert the JSON array to a string
                    std::string cve_match_json = cve_match_array.dump();

                    // std::cout << cve_match_array.size();

                    // Update 'programs' table with the JSON data
                    connection->prepare("update_programs", "UPDATE programs SET cve_match = $1 WHERE id = $2");
                    transaction.exec_prepared("update_programs", cve_match_json, id);
                    transaction.commit();
                    connection->unprepare("update_programs");

                    // Mark the record as processed
                    connection->prepare("update_is_cve_processed", "UPDATE programs SET is_cve_processed = 't' WHERE id = $1");

                    transaction.exec_prepared("update_is_cve_processed", id);
                    transaction.commit();
                    connection->unprepare("update_is_cve_processed");

                    cve_match_array.clear();
                }
            }
        }
        else
        {
            std::this_thread::sleep_for(std::chrono::seconds(2));
        }

        pool->ReturnConnection(connection);
    }
}

[[noreturn]] void Cve::run_vajra_winprograms_cve()
{
    while (true)
    {
        std::unordered_map<std::string, std::string> prepared_queries;
        ConfigurationParser config_parser("config.json");
        if (!config_parser.parse())
        {
            BOOST_LOG_TRIVIAL(fatal) << __SRCREF__ << "Cannot read configuration";
        }
        VaServerConfiguration va = config_parser.GetVaServerConfiguration();

        std::shared_ptr<ConnectionPool> conn_pool(
            new ConnectionPool(va.database.ConnectionVaString(), va.database_pool.maximum_connections, prepared_queries));
        // Query PostgreSQL for rows in 'programs' table
        auto connection = pool->GetConnection();
        auto connection_va = conn_pool->GetConnection();
        connection->prepare("get_vajra_winprograms_cpe", "SELECT id, cpe_string, version FROM vajra_winprograms where is_cve_processed is not true and is_processed is true order by id asc limit 500");
        pqxx::work transaction{*connection};
        pqxx::result result_cpe = transaction.exec_prepared("get_vajra_winprograms_cpe");
        transaction.commit();
        connection->unprepare("get_vajra_winprograms_cpe");
        pqxx::result get_cve_records;

        if (!result_cpe.empty())
        {
            nlohmann::json cve_match_array, cve_record;
            cve_match_array = nlohmann::json::array();
            for (pqxx::result::const_iterator i = result_cpe.begin(); i != result_cpe.end(); ++i)
            {
                long long id = i["id"].as<long long>();
                std::string version = i["version"].as<std::string>();
                if (!i["cpe_string"].is_null())
                {
                    std::string cpe_string = i["cpe_string"].as<std::string>();
                    // cpe_string is stored as an array in the database, parse it into individual strings
                    std::vector<std::string> cpe_strings;
                    boost::split(cpe_strings, cpe_string, boost::is_any_of(","));

                    // Determine the limit for iterating through CPE strings (limit to the first 3 strings)
                    size_t cpe_limit = std::min(static_cast<size_t>(3), cpe_strings.size());

                    for (size_t idx = 0; idx < cpe_limit; ++idx)
                    {
                        const std::string &single_cpe_string = cpe_strings[idx];

                        std::string query1 = "select * from nvd_cves where cpe_string like '%" + single_cpe_string + "%'";
                        connection_va->prepare("get_cve_for_cpe", query1);
                        pqxx::work transaction{*connection_va};
                        get_cve_records = transaction.exec_prepared("get_cve_for_cpe");
                        transaction.commit();
                        connection_va->unprepare("get_cve_for_cpe");
                        if (get_cve_records.empty())
                        {
                            // Extracting the substring till 'cpe:2.3:{part}:{vendor}:{product}:'
                            //  Counting the delimiter occurrence to get the substring till the 5th delimiter
                            std::string delimiter = ":";
                            size_t delimiter_count = 0;
                            size_t pos = 0;
                            while (delimiter_count < 5 && (pos = single_cpe_string.find(delimiter, pos)) != std::string::npos)
                            {
                                ++delimiter_count;
                                pos += delimiter.length();
                            }

                            std::string modified_cpe_string;
                            if (delimiter_count >= 5)
                            {
                                modified_cpe_string = single_cpe_string.substr(0, pos - delimiter.length());
                            }
                            else
                            {
                                modified_cpe_string = single_cpe_string; // Use the entire string if less than 5 delimiters
                            }

                            std::string query1 = "select * from nvd_cves where cpe_string like '%" + modified_cpe_string + "%'";

                            connection_va->prepare("get_cve_for_cpe", query1);
                            get_cve_records = transaction.exec_prepared("get_cve_for_cpe");
                            transaction.commit();
                            connection_va->unprepare("get_cve_for_cpe");
                        }
                        std::cout << get_cve_records.size() << std::endl;
                        if (!get_cve_records.empty())
                        {
                            for (unsigned int i = 0; i < get_cve_records.size(); ++i)
                            {
                                try
                                {
                                    std::string record_id = get_cve_records.at(i)["id"].as<std::string>();
                                    std::string cve_id = get_cve_records.at(i)["cve_id"].as<std::string>();
                                    std::string published = get_cve_records.at(i)["published"].as<std::string>();
                                    std::string lastModified = get_cve_records.at(i)["lastModified"].as<std::string>();
                                    std::string vulnStatus = get_cve_records.at(i)["vulnStatus"].as<std::string>();
                                    std::string descriptions = get_cve_records.at(i)["descriptions"].as<std::string>();
                                    std::string metrics = get_cve_records.at(i)["metrics"].as<std::string>();
                                    std::string weaknesses = get_cve_records.at(i)["weaknesses"].as<std::string>();
                                    std::string configurations = get_cve_records.at(i)["configurations"].as<std::string>();
                                    std::string reference = get_cve_records.at(i)["reference"].as<std::string>();
                                    std::string cpe_string = get_cve_records.at(i)["cpe_string"].as<std::string>();
                                    // std::cout << cpe_string << std::endl;

                                    long baseScore = get_cve_records.at(i)["baseScore"].as<long>();
                                    std::string baseSeverity = get_cve_records.at(i)["baseSeverity"].as<std::string>();
                                    long long exploitabilityScore = get_cve_records.at(i)["exploitabilityScore"].as<long long>();
                                    long long impactScore = get_cve_records.at(i)["impactScore"].as<long long>();
                                    std::string versionStartIncluding = get_cve_records.at(i)["versionStartIncluding"].as<std::string>();
                                    // std::cout << versionStartIncluding << std::endl;
                                    std::string versionEndIncluding = get_cve_records.at(i)["versionEndIncluding"].as<std::string>();
                                    // std::cout << versionEndIncluding << std::endl;

                                    if (versionCompare(versionStartIncluding, version) <= 0)
                                    {
                                        if (versionCompare(versionEndIncluding, version) >= 0)
                                        {
                                            // std::cout << version << " vulnerable\n";

                                            cve_record["id"] = record_id;
                                            cve_record["cve_id"] = cve_id;
                                            cve_record["published"] = published;
                                            cve_record["lastModified"] = lastModified;
                                            cve_record["vulnStatus"] = vulnStatus;
                                            cve_record["descriptions"] = descriptions;
                                            cve_record["metrics"] = metrics;
                                            cve_record["weaknesses"] = weaknesses;
                                            cve_record["configurations"] = configurations;
                                            cve_record["reference"] = reference;
                                            cve_record["cpe_string"] = cpe_string;
                                            cve_record["baseScore"] = baseScore;
                                            cve_record["baseSeverity"] = baseSeverity;
                                            cve_record["exploitabilityScore"] = exploitabilityScore;
                                            cve_record["impactScore"] = impactScore;

                                            cve_match_array.push_back(cve_record);
                                            // std::cout << cve_match_array << std::endl;
                                        }
                                    }
                                }
                                catch (const std::exception &e)
                                {
                                    std::cerr << e.what() << std::endl;
                                }
                            }
                        }
                    }
                    // Convert the JSON array to a string
                    std::string cve_match_json = cve_match_array.dump();

                    // std::cout << cve_match_array.size();

                    // Update 'programs' table with the JSON data
                    connection->prepare("update_vajra_winprograms", "UPDATE vajra_winprograms SET cve_match = $1 WHERE id = $2");
                    transaction.exec_prepared("update_vajra_winprograms", cve_match_json, id);
                    transaction.commit();
                    connection->unprepare("update_vajra_winprograms");

                    // Mark the record as processed
                    connection->prepare("update_is_cve_processed", "UPDATE vajra_winprograms SET is_cve_processed = 't' WHERE id = $1");
                    transaction.exec_prepared("update_is_cve_processed", id);
                    transaction.commit();
                    connection->unprepare("update_is_cve_processed");
                    cve_match_array.clear();
                }
            }
        }
        else
        {
            std::this_thread::sleep_for(std::chrono::seconds(2));
        }

        pool->ReturnConnection(connection);
    }
}

void Cve::run()
{
    std::thread run_programs_cve_thread(&Cve::run_programs_cve, this);
    std::thread run_vajra_winprograms_cve_thread(&Cve::run_vajra_winprograms_cve, this);

    run_programs_cve_thread.join();
    run_vajra_winprograms_cve_thread.join();
}