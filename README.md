To match vulnerabilities with software versions, CPEs are often associated with Common Vulnerability and Exposure (CVE) identifiers. This allows for precise linking of vulnerabilities to specific software versions, making it easier for security professionals to assess the impact of vulnerabilities and apply patches or security measures as needed.
Common Platform Enumeration (CPE)
Common Platform Enumeration (CPE) is a standardised method of describing and identifying classes of applications, operating systems, and hardware devices present among an enterprise's computing assets.
Vajra can collect information about installed products, identifying these products using their CPE names, and then use this standardised information to help make fully or partially automated decisions regarding the assets.
CPE names can be used as a standardised source of information for enforcing and verifying IT management policies across tools.
The current version of CPE is 2.3.
This graphic shows the current CPE 2.3 stack, with the most fundamental layer (Naming) at the bottom. Each higher layer builds on top of the layers below it.
CPE 2.3 Stack

Naming
The Naming specification defines the logical structure of Well-formed Names (WFNs), URI bindings, and formatted string bindings, and the procedures for converting WFNs to and from the bindings.
Name Matching
The Name Matching specification defines the procedures for comparing WFNs to each other so as to determine whether they refer to some or all of the same products.
Dictionary
The Dictionary specification defines the concept of a CPE dictionary, which is a repository of CPE names and metadata, with each name identifying a single class of IT product. The Dictionary specification defines processes for using the dictionary, such as how to search for a particular CPE name or look for dictionary entries that belong to a broader product class. Also, the Dictionary specification outlines all the rules that dictionary maintainers must follow when creating new dictionary entries and updating existing entries.
Applicability Language
The Applicability Language specification defines a standardised structure for forming complex logical expressions out of WFNs. These expressions, also known as applicability statements, are used to tag checklists, policies, guidance, and other documents with information about the product(s) to which the documents apply. For example, a security checklist for Mozilla Firefox 3.6 running on Microsoft Windows Vista could be tagged with a single applicability statement that ensures only systems with both Mozilla Firefox 3.6 and Microsoft Windows Vista will have the security checklist applied.




CPE String Structure:
cpe:2.3:a:microsoft:internet_explorer:8.0.6001:beta:*:*:*:*:*:*
cpe:2.3:{part}:{vendor}:{product}:{version}:{update}:
Reference : https://cpe.mitre.org/specification/#naming


Approach:
. These CPE construction properties are part, vendor, product,version and OS.
The necessary mapping to reach the minimum necessary data to construct CPEs could be as follows:

We need to do some processing for using the below columns of osquery tables
part: 	 The value will be ‘a’ (CPE uses to mark "application") for all current software tables
vendor:  Need to do name to vendor mapping.
product: Need to do name to product mapping.
version:  version is collected by osquery.


Example : { "id": 142,  "name": "Google Chrome.app",  "version": "90.0.4430.93", "source": "apps" }
The corresponding CPE looks like this: cpe:2.3:a:google:chrome:90.0.4430.93:*:*:*:*:*:*:*
a is the part
google is the vendor
chrome is the product
90.0.4430.93 is the version


Let's take example of osquery table python_packages and generating CPEs
Vajra will collect data and store it in the database.
To construct a valid CPE we need the part, vendor, product, and version items.
Potential solution:- 
Map osquery data from the python_packages table to the above items using regular expressions like:
osquery table python_packages -> CPE's part
osquery table python_packages -> CPE's vendor
osquery's name -> CPE's product
osquery's version -> CPE's version




Example for setuptools
table name = python_packages -> part = a
table name = python_packages -> vendor = python
name =  setuptools -> product = setuptools
version = 41.0.1 -> version = 41.0.1
CPE = part:vendor:product:version:*:*:*:*:*:*
CPE = cpe:2.3:a:python:setuptools:41.01:*:*:*:*:*:*


We can also schedule a query where we can union all and collect all the data in a single query and store it in our database.


Is this a good IDEA?


SELECT
 name AS name,
 version AS version,
 'apt_sources' AS source 
FROM apt_sources 
UNION
 SELECT
 name AS name,
 version AS version
 'deb_packages' AS source
 FROM deb_packages
UNION
SELECT
  package AS name,
  version AS version
  'portage_packages' AS source
FROM portage_packages
UNION
SELECT
  name AS name,
  version AS version
  'rpm_packages' AS source
FROM rpm_packages
UNION
SELECT
  name AS name,
  version AS version,
  'yum_sources' AS source
FROM yum_sources
UNION
SELECT
  name AS name,
  version AS version,
  'opera_extensions' AS source
FROM opera_extensions
UNION
SELECT
  name AS name,
  version AS version,
  'npm_packages' AS source
FROM npm_packages
UNION
SELECT
  name AS name,
  version AS version,
  'atom_packages' AS source
FROM atom_packages		
UNION
SELECT
  name AS name,
  version AS version,
  'python_packages' AS source
FROM python_packages;




We will then create CPE strings of the collected data and match with the nist cpe dictionary data 
For creating CPE string there are different command line tools which we can use such as 
The tool which nist provides, command line tool cpe2cve
Reference :  https://github.com/facebookincubator/nvdtools#cpe2cve
Go.vul tool open source on github
Reference : https://github.com/vulsio/go-cpe-dictionary
Tasks Completed
We have converted the xml nist cpe dictionary in json format. 
Able to enumerate softwares through our script.  
Pending Tasks
Check nvdtool
Check how to store the Nist dictionary xml data in our vajra fleet database
Try to do mapping of data to cpe string
Updation of nist cpe dictionary on daily basis
















The ingestion of software varies per platform
Tables fleetdm are using
atom_packages (lin, win)
deb_packages (lin)
homebrew_packages (mac)
npm_packages (lin, win)
package_bom (mac)
package_install_history (mac)
package_receipts (mac)
python_packages (lin, win)
rpm_packages (lin)


LINUX

deb_packages
portage_packages
rpm_packages
npm_packages
cached_users CROSS JOIN chrome_extensions USING (uid)
cached_users CROSS JOIN firefox_addons USING (uid)
cached_users CROSS JOIN atom_packages USING (uid)
python_packages

WINDOWS
programs
python_packages
ie_extensions
cached_users CROSS JOIN chrome_extensions USING (uid)
cached_users CROSS JOIN firefox_addons USING (uid)
chocolatey_packages
cached_users CROSS JOIN atom_packages USING (uid);

Tables we have

programs
deb_packages
rpm_packages
chocolatey_packages
chrome_extensions
python_packages


 
Tables we don't query yet

ie_extensions
firefox_addons
npm_packages
atom_packages
portage_packages


Fleet is running a UNION of several queries in each:

macOS
Windows
Linux

https://github.com/fleetdm/fleet/blob/00ed554bae4128e4813fc91c4887b177556ef22c/docs/01-Using-Fleet/standard-query-library/standard-query-library.yml#L64

Fleet's strategy for detecting vulnerabilities (CVEs) varies according to the host's platform. For macOS and Windows hosts, in general, CVEs are detected using the National Vulnerability Database (NVD).
For Linux hosts, CVEs are detected using the official OVAL definitions maintained by the different publishers (Canonical, Red Hat etc.).


First, Fleet retrieves the installed software for each host using osquery queries. Then, Fleet translates each installed software into Common Platform Enumeration (CPE) names.

A preprocessed CPE database generated by FleetDM to speed up the translation process: https://github.com/fleetdm/nvd/releases
DB browser

The database generated is processed from the original official CPE dictionary https://nvd.nist.gov/products/cpe.

The CPE xml file is converted to json to check what data is provided in the CPE dictionary.
VS Code



Then, using the CPEs, Fleet searches the list of Common Vulnerabilities and Exposure (CVE) identifiers listed in the NVD to detect the CVEs that match the defined CPEs.

The historical data for all CVEs and how to match to a CPE: from https://nvd.nist.gov/vuln/data-feeds
POSTMAN

If matches are found, they are exposed on each host's Host details page and on the Home page in the Fleet UI.


Our Next Steps

Create the queries for tables that we don't have.
Collection of data for Software in Windows. https://github.com/VajraSecurity/vajra-fleet/issues/180


Understand the CPE Sqlite database and to look up for CPE strings.
CPE to CVE by using NIST data.




















Software to CVE Architecture





Software to CPE (CPE_string_maker_Engine)

This is the most error prone part of the process. The CPE can have some vagueness.

Example:












Program Table
Sqlite by fleetdm
CPE_to_CVE

Name :- Mozilla Firefox ESR (x86 en-US)
Publisher :- Mozilla
Version :- 15.0.3
CPE :- cpe:2.3:a:mozilla:firefox_esr:115.0.3:*:*:*:*:*:*:*


Title:-  Mozilla Firefox ESR115.0.3
Vendor:- mozilla
Version :-  15.0.3
CPE :- cpe:2.3:a:mozilla:firefox_esr:115.0.3:*:*:*:*:*:*:*


Name :- Mozilla Maintenance Service
Publisher :- Mozilla
Version :- 15.0.3
CPE :- cpe:2.3:a:mozilla:firefox:115.0.3:*:*:*:*:*:*:*
Title:-  Mozilla Firefox 115.0.3
Vendor:- mozilla
Version :-  15.0.3
CPE :- cpe:2.3:a:mozilla:firefox:115.0.3:*:*:*:*:*:*:*


Name :- WinRAR 4.20 (32-bit)
Version :- 4.20.0
Publisher :- winrar
No data for the version 4.20













We are fetching the NVD data using NVD api’s & storing in our postgresql database table nvd_cve. 
 
In CPE_string_maker_Engine the data present in the programs table is passed and a lookup is done in the sqlite table we are using fleetdm NVD sqlite release (https://github.com/fleetdm/nvd/releases).
Here is the tricky part because the exact matching gives us the cpe string but if there is not an exact match then it is not much of help to us.
As of now there is no map or list of all the software available and how it's presented in each platform, so the "software to CPE" translation process is going to be evolving constantly.

Once we have the cpe_string we will check for that cpe string in the nvd_cve table & if CVE is present data of CVE is pushed to the programs table.
