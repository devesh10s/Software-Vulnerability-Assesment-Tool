#include <iostream>
#include <pqxx/pqxx>
#include <sqlite3.h>
#include "../3rdparty/json.hpp"
#include "cpe.h"

#include <thread>
#include <utility>
#include "../common/hostinfo.h"
#include "../common/logger.h"

#include <boost/beast/http.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/algorithm/string.hpp>
#include "../3rdparty/RapidFuzz/rapidfuzz/fuzz.hpp"
#include <fstream> 

std::string removeTrailingZero(const std::string &version)
{                                 
    std::string modifiedVersion = version;
    size_t found = modifiedVersion.find_last_of('.');
    if (found != std::string::npos)
    {
        std::string lastPart = modifiedVersion.substr(found + 1);
        if (lastPart == "0")
        {
            modifiedVersion = modifiedVersion.substr(0, found);
        }
    }
    return modifiedVersion;
}

Cpe::Cpe(std::shared_ptr<ConnectionPool> pool)
{
    this->pool = std::move(pool);
}

[[noreturn]] void Cpe::run_programs()
{
    while (true)
    {

        // Check if cpe-data.sqlite file exists
        std::ifstream file("/var/vajra/cpe-data.sqlite");
        if (!file.good()) {
            // If file does not exist, sleep for 10 seconds and continue
            std::this_thread::sleep_for(std::chrono::seconds(10));
            continue;
        }
        file.close();
        // Connect to PostgreSQL

        // Query PostgreSQL for rows in 'programs' table
        auto connection = pool->GetConnection();
        connection->prepare("get_programs", "SELECT id, name, version, publisher FROM programs where is_processed is not true order by id asc limit 500");
        pqxx::work transaction{*connection};
        pqxx::result result = transaction.exec_prepared("get_programs");
        transaction.commit();
        connection->unprepare("get_programs");

        // Connect to SQLite
        sqlite3 *sqlite_conn;
        sqlite3_open("/var/vajra/cpe-data.sqlite", &sqlite_conn);
        if (!result.empty())
        {
            // Loop through PostgreSQL results
            for (pqxx::result::size_type i = 0; i < result.size(); ++i)
            {
                try
                {
                    int id = result[i][0].as<int>();
                    std::string name = result[i][1].as<std::string>();
                    std::string version = result[i][2].as<std::string>();
                    std::string publisher = result[i][3].as<std::string>();
                    std::string modifiedVersion = removeTrailingZero(version);

                    // Construct the query for SQLite
                    std::string sqlite_query = "SELECT cpe23, title FROM cpe_2 WHERE vendor LIKE '%" + publisher + "%' AND version LIKE '%" + modifiedVersion + "%'";

                    // Execute the SQLite query

                    std::vector<std::string> cpe_array;
                    std::vector<std::string> bundle_names; // Array to store bundle names

                    sqlite3_stmt *stmt;
                    if (sqlite3_prepare_v2(sqlite_conn, sqlite_query.c_str(), -1, &stmt, nullptr) == SQLITE_OK)
                    {
                        bool foundResult = false;
                        while (sqlite3_step(stmt) == SQLITE_ROW)
                        {
                            std::string cpe23 = reinterpret_cast<const char *>(sqlite3_column_text(stmt, 0));

                            std::string title = reinterpret_cast<const char *>(sqlite3_column_text(stmt, 1));

                            // Use fuzzy string matching to compare 'name' and 'title'
                            double similarity = rapidfuzz::fuzz::ratio(name, title);

                            // Set a threshold for similarity (adjust as needed)
                            if (similarity >= 70)
                            {
                                foundResult = true;
                                cpe_array.push_back(cpe23);
                                bundle_names.push_back(title);
                            }
                        }
                        if (!foundResult)
                        {
                            // Only search for vendor
                            sqlite3_finalize(stmt); // Finalize the previous prepared statement

                            std::string vendorQuery = "SELECT cpe23, title FROM cpe_2 WHERE vendor LIKE '%" + publisher + "%'";
                            if (sqlite3_prepare_v2(sqlite_conn, vendorQuery.c_str(), -1, &stmt, nullptr) == SQLITE_OK)
                            {
                                while (sqlite3_step(stmt) == SQLITE_ROW)
                                {
                                    std::string cpe23 = reinterpret_cast<const char *>(sqlite3_column_text(stmt, 0));
                                    std::string title = reinterpret_cast<const char *>(sqlite3_column_text(stmt, 1));

                                    // Use fuzzy string matching to compare 'name' and 'title' for vendor search
                                    double similarity = rapidfuzz::fuzz::ratio(name, title);

                                    // Set a threshold for similarity (adjust as needed)
                                    if (similarity >= 70)
                                    {
                                        cpe_array.push_back(cpe23);
                                        bundle_names.push_back(title);
                                    }
                                }
                            }
                        }

                        if (!cpe_array.empty())
                        {
                            std::string cpe_string = nlohmann::json(cpe_array).dump();
                            std::string bundle_names_string = nlohmann::json(bundle_names).dump();

                            // Update PostgreSQL with the found CPE string and bundle name
                            connection->prepare("update_cpe_string", "UPDATE programs SET cpe_string = $1, bundle_name = $2 WHERE id = $3");
                            transaction.exec_prepared("update_cpe_string", cpe_string, bundle_names_string, id);
                            transaction.commit();
                            connection->unprepare("update_cpe_string");

                            
                        }
                        else
                        {
                            // If no results were found at all, update PostgreSQL indicating no matches
                            connection->prepare("update_cpe_string", "UPDATE programs SET cpe_string = 'No matches found', bundle_name = 'No matches found' WHERE id = $1");
                            transaction.exec_prepared("update_cpe_string", id);
                            transaction.commit();
                            connection->unprepare("update_cpe_string");
                        }

                        connection->prepare("update_cpe_is_processed", "UPDATE programs SET is_processed = 't' WHERE id = $1");
                        transaction.exec_prepared("update_cpe_is_processed", id);
                        transaction.commit();
                        connection->unprepare("update_cpe_is_processed");

                        sqlite3_finalize(stmt); // Finalize the statement
                    }
                }
                catch (const std::exception &e)
                {
                    std::cerr << e.what() << std::endl;
                }
            }
        }
        else
        {
            std::this_thread::sleep_for(std::chrono::seconds(2));
        }
        // Commit the PostgreSQL transaction

        // Close SQLite connection
        sqlite3_close(sqlite_conn);

        std::cout << "Data updated successfully." << std::endl;
        pool->ReturnConnection(connection);
    }
}

[[noreturn]] void Cpe::run_vajra_winprograms()
{
    while (true)
    {
        // Check if cpe-data.sqlite file exists
        std::ifstream file("/var/vajra/cpe-data.sqlite");
        if (!file.good()) {
            // If file does not exist, sleep for 10 seconds and continue
            std::this_thread::sleep_for(std::chrono::seconds(10));
            continue;
        }
        file.close();
        // Connect to PostgreSQL

        // Query PostgreSQL for rows in 'programs' table
        auto connection = pool->GetConnection();
        connection->prepare("get_vajra_winprograms", "SELECT id, name, version, publisher FROM vajra_winprograms where is_processed is not true order by id asc limit 500");
        pqxx::work transaction{*connection};
        pqxx::result result = transaction.exec_prepared("get_vajra_winprograms");
        transaction.commit();
        connection->unprepare("get_vajra_winprograms");

        // Connect to SQLite
        sqlite3 *sqlite_conn;
        sqlite3_open("/var/vajra/cpe-data.sqlite", &sqlite_conn);
        if (!result.empty())
        {
            // Loop through PostgreSQL results
            for (pqxx::result::size_type i = 0; i < result.size(); ++i)
            {
                try
                {
                    int id = result[i][0].as<int>();
                    std::string name = result[i][1].as<std::string>();
                    std::string version = result[i][2].as<std::string>();
                    std::string publisher = result[i][3].as<std::string>();
                    std::string modifiedVersion = removeTrailingZero(version);

                    // Construct the query for SQLite
                    std::string sqlite_query = "SELECT cpe23, title FROM cpe_2 WHERE vendor LIKE '%" + publisher + "%' AND version LIKE '%" + modifiedVersion + "%'";

                    // Execute the SQLite query

                    std::vector<std::string> cpe_array;
                    std::vector<std::string> bundle_names; // Array to store bundle names

                    sqlite3_stmt *stmt;
                    if (sqlite3_prepare_v2(sqlite_conn, sqlite_query.c_str(), -1, &stmt, nullptr) == SQLITE_OK)
                    {
                        bool foundResult = false;
                        while (sqlite3_step(stmt) == SQLITE_ROW)
                        {
                            std::string cpe23 = reinterpret_cast<const char *>(sqlite3_column_text(stmt, 0));

                            std::string title = reinterpret_cast<const char *>(sqlite3_column_text(stmt, 1));

                            // Use fuzzy string matching to compare 'name' and 'title'
                            double similarity = rapidfuzz::fuzz::ratio(name, title);

                            // Set a threshold for similarity (adjust as needed)
                            if (similarity >= 70)
                            {
                                foundResult = true;
                                cpe_array.push_back(cpe23);
                                bundle_names.push_back(title);
                            }
                        }
                        if (!foundResult)
                        {
                            // Only search for vendor
                            sqlite3_finalize(stmt); // Finalize the previous prepared statement

                            std::string vendorQuery = "SELECT cpe23, title FROM cpe_2 WHERE vendor LIKE '%" + publisher + "%'";
                            if (sqlite3_prepare_v2(sqlite_conn, vendorQuery.c_str(), -1, &stmt, nullptr) == SQLITE_OK)
                            {
                                while (sqlite3_step(stmt) == SQLITE_ROW)
                                {
                                    std::string cpe23 = reinterpret_cast<const char *>(sqlite3_column_text(stmt, 0));
                                    std::string title = reinterpret_cast<const char *>(sqlite3_column_text(stmt, 1));

                                    // Use fuzzy string matching to compare 'name' and 'title' for vendor search
                                    double similarity = rapidfuzz::fuzz::ratio(name, title);

                                    // Set a threshold for similarity (adjust as needed)
                                    if (similarity >= 70)
                                    {
                                        cpe_array.push_back(cpe23);
                                        bundle_names.push_back(title);
                                    }
                                }
                            }
                        }

                        if (!cpe_array.empty())
                        {
                            std::string cpe_string = nlohmann::json(cpe_array).dump();
                            std::string bundle_names_string = nlohmann::json(bundle_names).dump();

                            // Update PostgreSQL with the found CPE string and bundle name
                            connection->prepare("update_cpe_string", "UPDATE vajra_winprograms SET cpe_string = $1, bundle_name = $2 WHERE id = $3");
                            transaction.exec_prepared("update_cpe_string", cpe_string, bundle_names_string, id);
                            transaction.commit();
                            connection->unprepare("update_cpe_string");

                            
                        }
                        else
                        {
                            // If no results were found at all, update PostgreSQL indicating no matches
                            connection->prepare("update_cpe_string", "UPDATE vajra_winprograms SET cpe_string = 'No matches found', bundle_name = 'No matches found' WHERE id = $1");
                            transaction.exec_prepared("update_cpe_string", id);
                            transaction.commit();
                            connection->unprepare("update_cpe_string");
                        }

                        connection->prepare("update_cpe_is_processed", "UPDATE vajra_winprograms SET is_processed = 't' WHERE id = $1");
                        transaction.exec_prepared("update_cpe_is_processed", id);
                        transaction.commit();
                        connection->unprepare("update_cpe_is_processed");

                        sqlite3_finalize(stmt); // Finalize the statement
                    }
                }
                catch (const std::exception &e)
                {
                    std::cerr << e.what() << std::endl;
                }
            }
        }
        else
        {
            std::this_thread::sleep_for(std::chrono::seconds(2));
        }
        // Commit the PostgreSQL transaction

        // Close SQLite connection
        sqlite3_close(sqlite_conn);

        std::cout << "Data updated successfully." << std::endl;
        pool->ReturnConnection(connection);
    }
}

void Cpe::run()
{
    std::thread program_cpe_thread(&Cpe::run_programs, this);
    std::thread vajra_winprogram_cpe_thread(&Cpe::run_vajra_winprograms, this);

    program_cpe_thread.join();
    vajra_winprogram_cpe_thread.join();
}